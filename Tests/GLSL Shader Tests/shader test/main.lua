local draw = love.graphics.drawlocal rect = love.graphics.rectanglelocal random = math.randomlocal floor = math.floorfunction love.load()effect = love.graphics.newPixelEffect [[        // REMEMBER TO ADD ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        extern vec2 mouse;        extern Image test;        vec4 effect(vec4 global_color, Image texture, vec2 texture_coords, vec2 pixel_coords)        {          vec4 sum = vec4(0.0);          int size = 60;          if (mouse.x > pixel_coords.x-size)  {            if (mouse.x < pixel_coords.x+size){              sum += (1 + 0.2 - abs(mouse.x - pixel_coords.x)/size)*Texel(test, vec2(texture_coords.x, texture_coords.y));              }                      }          return sum;            //return vec4( mouse.x/pixel_coords.x,mouse.y/pixel_coords.y, 0, 1.0);        }    ]]-- blur    effect2 = love.graphics.newPixelEffect [[extern Image test; // the texture with the scene you want to blur number blurSize = 1.0/512.0;  vec4 effect(vec4 global_color, Image texture, vec2 texture_coords, vec2 pixel_coords){   vec4 sum = vec4(0.0);    sum += texture2D(test, vec2(texture_coords.x - 4.0*blurSize, texture_coords.y)) * 0.05;   sum += texture2D(test, vec2(texture_coords.x - 3.0*blurSize, texture_coords.y)) * 0.09;   sum += texture2D(test, vec2(texture_coords.x - 2.0*blurSize, texture_coords.y)) * 0.12;   sum += texture2D(test, vec2(texture_coords.x - blurSize, texture_coords.y)) * 0.15;   sum += texture2D(test, vec2(texture_coords.x, texture_coords.y)) * 0.16;   sum += texture2D(test, vec2(texture_coords.x + blurSize, texture_coords.y)) * 0.15;   sum += texture2D(test, vec2(texture_coords.x + 2.0*blurSize, texture_coords.y)) * 0.12;   sum += texture2D(test, vec2(texture_coords.x + 3.0*blurSize, texture_coords.y)) * 0.09;   sum += texture2D(test, vec2(texture_coords.x + 4.0*blurSize, texture_coords.y)) * 0.05;    return sum;}    ]]effect3 = love.graphics.newPixelEffect [[// REMEMBER TO ADD ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;               vec4 effect(vec4 global_color, Image texture, vec2 texture_coords, vec2 pixel_coords)        {          vec4 sum = vec4(0.0);          vec4 t1 = Texel(texture, vec2(texture_coords.x-1*gl_FragCoord.w, texture_coords.y));          vec4 t2 = Texel(texture, vec2(texture_coords.x, texture_coords.y));          number t3 = (t1.r + t1.g + t1.b)/3.0;          number t4 = (t2.r + t2.g + t2.b)/3.0;            if ( t3 - t4 > 0.4) {              sum.r += 1.0;              sum.g += 1.0;              sum.b += 1.0;              sum.a += 1.0;            }                             return sum;        }]]sw, sh = love.graphics.getWidth() ,love.graphics.getHeight()  image = love.graphics.newImage("23.jpg")effect:send("test",image)   effect2:send("test", image)   fb = love.graphics.newCanvas()    love.graphics.setRenderTarget(fb) love.graphics.rectangle('fill', 10,10,790,500) love.graphics.setRenderTarget()       endfunction love.draw()        love.graphics.setPixelEffect(effect3) --  love.graphics.draw(fb)   love.graphics.draw(image)   --love.graphics.rectangle('fill', 10,10,790,500)   endlocal t = 0function love.update(dt)    t = t + dt        local x, y = love.mouse.getPosition()   effect:send("mouse", x,(sh-y))  end--[=[ADDED FUNCTIONS---------------supported = love.graphics.hasPixelEffects()  * returns true if pixel effects are supportedeffect = love.graphics.newPixelEffect(filename or code)  * create a new effect from code or a filelove.graphics.setPixelEffect(effect)  * apply pixel effect to all images and framebuffers drawn beyond this pointlove.graphics.setPixelEffect()  * turn effects offeffect:send(shader_variable_name, value, ...)  * send values ("uniforms") to the shader. the following is supported:    effect:send(var, number)    effect:send(var, x,y), ..., effect:send(name, x,y,z,w) -- send a vector    effect:send(var, {x,y,z,w}) -- also sends a vector    effect:send(var, {{a,b}, {c,d}}), ... -- sends a matrix (up to 4x4 matrices)    effect:send(var, image) -- sends an Image object ("sampler")    effect:send(var, framebuffer) -- sends a Framebuffer object (also a "sampler")EFFECT LANGUAGE---------------Essentially GLSL 1.2 (specified here: http://www.opengl.org/registry/doc/GLSLangSpec.Full.1.20.8.pdf)BUT:Instead of writing your own main() function, you define a special functionthat returns the pixel color. The prototype of that function is  vec4 effect(vec4 global_color, Image texture, vec2 texture_coords, vec2 pixel_coords);`global_color'    is the color set with love.graphics.setColor().`texture'         is contains pixel colors if the effect is applied to an image                  or framebuffer.`texture_coords'  are the texture coordinates of the current pixel (0 <= x,y <= 1)`pixel_coords'    are the coordinates of the pixel (0 <= x,y <= WIDTH,HEIGHT)There are a few keyword mappings to make things less scary:GLSL              | Effect language     | Comment------------------+---------------------+--------------------------------------float             | number              |sampler2D         | Image               | LÃ–VE only supports 2D textures anywayuniform           | extern              | less technical termtexture2D(tex,st) | Texel(tex,st)       | `tex' is an image, `st' is a vec2.oO Things not to do: * Define a function called `main()' (because it's already there). * Use any of the keywords, function names and special variable names defined   in the GLSL document from above as variable names. Especially anything that   begins with `gl_'. * Expecting meaningful error messages if shader compilation fails. * Forget to put a semicolon (;) at the end of every statement.--]=]